from fastapi import FastAPI
from pymongo import MongoClient
from dotenv import load_dotenv
from fastapi.responses import HTMLResponse
from fastapi.responses import JSONResponse
from fastapi import FastAPI, File, UploadFile
import androguard.core.bytecodes.apk as apk
import androguard.core.analysis.analysis as analysis
import androguard.core.bytecodes.dvm as dvm
import pandas as pd
import pickle
import tempfile
import os
import time


load_dotenv()

app = FastAPI()

ds = {}
ds_columns = []
single_name_columns = []


def load_ds():
    global ds, ds_columns, single_name_columns
    ds = pd.read_csv('drebin215dataset5560malware9476benign_modified.csv')
    ds_columns = list(ds.columns)
    single_name_columns = [col.split(".")[-1] for col in ds_columns]


load_ds()


@app.on_event("startup")
async def startup_event():
    app.state.client = MongoClient(os.getenv('MONGODB_URL'))
    app.state.db = app.state.client['AMD_HASH']
    print('Connection successfull with DB..')


@app.on_event("shutdown")
async def shutdown_event():
    app.state.client.close()


def get_app_information(app):
    package_name = app.get_package()
    app_name = app.get_app_name()
    version_name = app.get_androidversion_name()
    version_code = app.get_androidversion_code()
    print('got apk')
    info = {
        "Package Name:": package_name,
        "App Name:": app_name,
        "Version Name:": version_name,
        "Version Code:": version_code
    }
    return info


def get_app_features(app):
    global ds, ds_columns, single_name_columns
    dalvikVM = dvm.DalvikVMFormat(app.get_dex())
    apk_all_features = {}

    def get_permission(app):
        prm = set()
        permissions = app.get_permissions()
        for perm in permissions:
            p = perm.split('.')
            prm.add(p[2])
            apk_all_features[p[2]] = 1
            # print('Permissions :', p[2])
        print('permissions derived')
        return prm

    def get_intent(app):
        ints = set()
        manifest = app.get_android_manifest_xml()
        # # Get all the activities with their intent filters
        activities = manifest.findall(".//activity")

        # Iterate through activities to extract intent filters and actions

        for activity in activities:
            intent_filters = activity.findall(".//intent-filter")
            for intent_filter in intent_filters:
                actions = intent_filter.findall(".//action")
                for action in actions:
                    action_name = action.get(
                        "{http://schemas.android.com/apk/res/android}name")
                    # print("Action:", action_name)
                    ints.add(action_name)
                    apk_all_features[action_name] = 1
        print('Actions derived')
        return ints

    # getting api calls given in apk
    def get_app_api_signature(app):
        api_calls = set()
        for method in dalvikVM.get_methods():
            if method.get_name() in single_name_columns:
                api_calls.add(method.get_name())
                apk_all_features[method.get_name()] = 1

        return api_calls

    def get_app_test_dataframe():
        apk_test_set = {}
        for col in ds.columns:
            if col == 'class':
                continue
            if col not in apk_all_features:
                apk_test_set[col] = [0]
            else:
                apk_test_set[col] = [1]

        return pd.DataFrame(apk_test_set)

    perms = get_permission(app)
    ints = get_intent(app)
    api_call_signatures = get_app_api_signature(app)
    res = {"Permissions": perms, "Actions": ints,
           "API calls": api_call_signatures,
           "feature": get_app_test_dataframe()}
    return res


def load_model():
    with open('drebin_dt_model_random0.pkl', 'rb')as file:
        drebin_model = pickle.load(file)
    return drebin_model


def predict(dataframe) -> str:
    model = load_model()
    res = model.predict(dataframe)[0]
    if res == 1:
        return "File is Benign"
    else:
        return "File is Malicious"


@app.get("/")
async def root():
    html_content = """
    <html>
    <head>
        <title>FastAPI H1 Example</title>
    </head>
    <body>
        <h1>Hello, FastAPI!</h1>
    </body>
    </html>
    """
    # return HTMLResponse(content=html_content)
    msg = "Hello world"
    # print(JSONResponse(msg))
    return JSONResponse(msg)


@app.post('/upload')
async def upload(file: UploadFile):
    starttime = time.time()
    contents = await file.read()
    info = {}
    try:
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(contents)
            temp_file_path = temp_file.name
            a = apk.APK(temp_file_path)
            info['App metadata'] = get_app_information(a)
            app_features = get_app_features(a)
            info["Permission"] = app_features['Permissions']
            info["Actions"] = app_features['Actions']
            info["API calls"] = app_features['API calls']
            info['Result'] = predict(app_features['feature'])
            temp_file.close()
            os.remove(temp_file_path)

    except Exception as e:
        print(e.__cause__)
        return HTMLResponse(content=f"An error occurred: {str(e)}")

    if not info:
        return "Error occured"
    endtime = time.time()
    timetook = endtime - starttime
    print(f'Time taken to upload - {timetook}')
    return info


@app.get('/file/{file}')
async def upload(file: str):
    print('request...')
    with open('testAPK/'+file, "rb") as file:
        file_contents = file.read()
    contents = file_contents
    info = {}
    try:

        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(contents)
            temp_file_path = temp_file.name
            a = apk.APK(temp_file_path)
            info["App metadata"] = get_app_information(a)
            app_features = get_app_features(a)
            info["Permission"] = app_features['Permissions']
            info["Actions"] = app_features['Actions']
            info["API calls"] = app_features['API calls']
            info["Result"] = predict(app_features['feature'])
            temp_file.close()
            os.remove(temp_file_path)

    except Exception as e:
        # print(e)
        return HTMLResponse(content=f"An error occurred: {str(e)}")

    if not info:
        return "Error occured"

    return info


@app.post('/db/findSHA256/{sha256}')
async def findSHA256(sha256: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"sha256_hash": sha256}))
    return len(doclist)


@app.post('/db/findSHA1/{sha1}')
async def findSHA1(sha1: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"sha1_hash": sha1}))
    return len(doclist)


@app.post('/db/findMD5/{md5}')
async def findMD5(md5: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"md5_hash": md5}))
    return len(doclist)
