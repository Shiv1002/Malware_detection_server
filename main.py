import json
import requests
import time
import os
import tempfile
import pickle
import pandas as pd
from fastapi import FastAPI, HTTPException
from pymongo import MongoClient
from dotenv import load_dotenv
from fastapi.responses import HTMLResponse
from fastapi.responses import JSONResponse
from fastapi import FastAPI, File, UploadFile
import androguard.core.bytecodes.apk as apk
import androguard.core.analysis.analysis as analysis
import androguard.core.bytecodes.dvm as dvm
import pydantic
from bson import ObjectId
pydantic.json.ENCODERS_BY_TYPE[ObjectId] = str
load_dotenv()

app = FastAPI()

ds = {}
ds_columns = []
single_name_columns = []
vturl = "https://www.virustotal.com/api/v3"
vtHeaders = {
    "accept": "application/json",
    "x-apikey": os.getenv('VT_API_KEY')
}


def load_ds():
    global ds, ds_columns, single_name_columns
    ds = pd.read_csv('drebin215dataset5560malware9476benign_modified.csv')
    ds_columns = list(ds.columns)
    single_name_columns = [col.split(".")[-1] for col in ds_columns]


load_ds()


@app.on_event("startup")
async def startup_event():
    app.state.client = MongoClient('mongodb://localhost:27017/')
    app.state.db = app.state.client['AMD_HASH']
    print('Connection successfull with DB..')


@app.on_event("shutdown")
async def shutdown_event():
    app.state.client.close()


def get_app_information(app):
    package_name = app.get_package()
    app_name = app.get_app_name()
    version_name = app.get_androidversion_name()
    version_code = app.get_androidversion_code()
    print('got apk')
    info = {
        "Package Name:": package_name,
        "App Name:": app_name,
        "Version Name:": version_name,
        "Version Code:": version_code
    }
    return info


def get_app_features(app):
    global ds, ds_columns, single_name_columns
    apk_all_features = {}

    def get_permission(app):
        prm = set()
        permissions = app.get_permissions()
        for perm in permissions:
            p = perm.split('.')
            prm.add(p[2])
            apk_all_features[p[2]] = 1
            # print('Permissions :', p[2])
        print('permissions derived')
        return list(prm)

    def get_intent(app):
        ints = set()
        manifest = app.get_android_manifest_xml()
        # # Get all the activities with their intent filters
        activities = manifest.findall(".//activity")

        # Iterate through activities to extract intent filters and actions

        for activity in activities:
            intent_filters = activity.findall(".//intent-filter")
            for intent_filter in intent_filters:
                actions = intent_filter.findall(".//action")
                for action in actions:
                    action_name = action.get(
                        "{http://schemas.android.com/apk/res/android}name")
                    # print("Action:", action_name)
                    ints.add(action_name)
                    apk_all_features[action_name] = 1
        print('Actions derived')
        return list(ints)

    def get_app_test_dataframe():
        apk_test_set = {}
        for col in ds.columns:
            if col == 'class':
                continue
            if col not in apk_all_features:
                apk_test_set[col] = [0]
            else:
                apk_test_set[col] = [1]
        # print(apk_test_set)
        return pd.DataFrame(apk_test_set)

    perms = get_permission(app)
    ints = get_intent(app)
    res = {"Permissions": perms, "Actions": ints,
           "feature": get_app_test_dataframe()}
    return res


def load_model():
    with open('drebin_dt_model_random0.pkl', 'rb')as file:
        drebin_model = pickle.load(file)
    return drebin_model


def predict(dataframe) -> str:
    model = load_model()
    res = model.predict(dataframe)[0]
    if res == 1:
        return "File is Benign"
    else:
        return "File is Malicious"


def getVTResponse(vtanalysis_link):

    fileId = vtanalysis_link['data']['id']

    res = {}

    # get analyses report
    try:
        res = requests.get(vturl+'/analyses/'+fileId, headers=vtHeaders)
        res = json.loads(res.text)

    except Exception as e:
        print(f'vt analysis request failed: {e}')
        return

    file_info = res['meta']['file_info']
    stats = res['data']['attributes']['stats']

    f_data = {
        "links": res['data']['links'],
        "size": file_info['size'],
        "stats": stats,
        "file_info": res['meta']['file_info'],
    }

    # try:
    #     item_information = json.loads(requests.get(
    #         f_data['links']['item'], headers=vtHeaders).text)

    #     f_data['Sandbox_verdicts'] = item_information['data']['attributes']['sandbox_verdicts']

    # except Exception as e:
    #     print(f'sandbox analyis requests failed: {e}')
    #     f_data['data'] = item_information['data']
    return f_data


async def insertFileDataIntoDB(data):
    # # store analyses report in db
    try:
        res = app.state.db['HashDetail'].insert_one(data)
    except Exception as e:
        print('Error while saving data', e)
        raise HTTPException(
            status_code=500, contents=f"An error occurred: {str(e)}")


@app.get("/")
async def root():
    # return HTMLResponse(content=html_content)
    msg = "Hello world"
    # print(JSONResponse(msg))
    return JSONResponse(msg)


@app.post('/upload')
async def upload(file: UploadFile):
    starttime = time.time()
    contents = await file.read()
    info = {}
    try:
        # create a temporary file
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(contents)
            temp_file_path = temp_file.name

        # post requests  to vt to post file for analyes
            f = {"file": contents}
            vtres = requests.post(vturl+'/files', files=f, headers=vtHeaders)
            # extract information from analyses

            vtData = getVTResponse(json.loads(vtres.text))

            # static analyiss
            a = apk.APK(temp_file_path)
            info['App_metadata'] = get_app_information(a)
            app_features = get_app_features(a)
            info["Permission"] = app_features['Permissions']
            info["Actions"] = app_features['Actions']

            info['Dynamic_data'] = vtData
            info['SHA256'] = vtData['file_info']['sha256']
            info['SHA1'] = vtData['file_info']['sha1']
            info['MD5'] = vtData['file_info']['md5']

            info['Result'] = 'File is malicious' if vtData['stats']['malicious'] > 0 else 'File is benign'

            # close temporary file otherwise
            # winerror occurs(another process cannot access file)
            temp_file.close()
            os.remove(temp_file_path)

    except Exception as e:
        return HTMLResponse(status_code=500, content=f"An error occurred: {str(e)}")

    if not info:
        return "Error occured"

    endtime = time.time()
    timetook = endtime - starttime
    print(f'Time taken to upload - {timetook}')

    # add data into db
    try:
        await insertFileDataIntoDB(info)
    except Exception as e:
        return HTMLResponse(status_code=500, content=f"An error occurred: {str(e)}")

    return HTMLResponse(status_code=200, content=str(info))


@app.get('/hash/{hash}')
async def getHashDetail(hash: str):

    try:
        doc = app.state.db['HashDetail'].find_one({'SHA256': hash})
    except Exception as e:
        HTMLResponse(status_code=500, content=f"An error occurred: {str(e)}")

    # remove unserlizable objectId
    doc.pop('_id')

    return HTMLResponse(status_code=200, content=json.dumps(doc))


@app.get('/file/{file}')
async def upload(file: str):
    print('request...')
    with open('testAPK/'+file, "rb") as file:
        file_contents = file.read()
    contents = file_contents
    info = {}
    try:

        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(contents)
            temp_file_path = temp_file.name
            a = apk.APK(temp_file_path)
            info["App metadata"] = get_app_information(a)
            app_features = get_app_features(a)
            info["Permission"] = app_features['Permissions']
            info["Actions"] = app_features['Actions']
            info["Result"] = predict(app_features['feature'])

            temp_file.close()
            os.remove(temp_file_path)

    except Exception as e:
        # print(e)
        return HTMLResponse(content=f"An error occurred: {str(e)}")

    if not info:
        return "Error occured"

    return info


@app.get('/dir/{dir}')
async def uploadDir(dir: str):
    dir_test_set = {}
    all_items = os.listdir(dir)
    # Filter out directories to get only files
    # files = [item for item in all_items if os.path.isfile(os.path.join(folder_path, item))]
    for item in all_items:
        with open('testAPK/'+item, "rb") as file:
            file_contents = file.read()
        contents = file_contents
        info = {}
        try:

            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                temp_file.write(contents)
                temp_file_path = temp_file.name
                a = apk.APK(temp_file_path)
                info["App metadata"] = get_app_information(a)
                app_features = get_app_features(a)
                info["Permission"] = app_features['Permissions']
                info["Actions"] = app_features['Actions']
                info["Result"] = predict(app_features['feature'])
                temp_file.close()
                os.remove(temp_file_path)

        except Exception as e:
            # print(e)
            return HTMLResponse(status_code=500, content=f"An error occurred: {str(e)}")

        if not info:
            return "Error occured"

        dir_test_set[item] = info
    return dir_test_set


@app.post('/db/findSHA256/{sha256}')
async def findSHA256(sha256: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"sha256_hash": sha256}))
    return len(doclist)


@app.post('/db/findSHA1/{sha1}')
async def findSHA1(sha1: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"sha1_hash": sha1}))
    return len(doclist)


@app.post('/db/findMD5/{md5}')
async def findMD5(md5: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"md5_hash": md5}))
    return len(doclist)
