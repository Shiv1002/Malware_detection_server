from fastapi import FastAPI
from pymongo import MongoClient
from dotenv import load_dotenv
from fastapi.responses import HTMLResponse
from fastapi.responses import JSONResponse
from fastapi import FastAPI, File, UploadFile
import androguard.core.bytecodes.apk as apk
import androguard.core.analysis.analysis as analysis
import androguard.core.bytecodes.dvm as dvm
import pandas as pd
import pickle
import tempfile
import os
import time
import requests
import json
load_dotenv()

app = FastAPI()

ds = {}
ds_columns = []
single_name_columns = []
vturl = "https://www.virustotal.com/api/v3"
vtHeaders = {
    "accept": "application/json",
    "x-apikey": os.getenv('VT_API_KEY')
}


def load_ds():
    global ds, ds_columns, single_name_columns
    ds = pd.read_csv('drebin215dataset5560malware9476benign_modified.csv')
    ds_columns = list(ds.columns)
    single_name_columns = [col.split(".")[-1] for col in ds_columns]


load_ds()


@app.on_event("startup")
async def startup_event():
    app.state.client = MongoClient('MONGODB_URL')
    app.state.db = app.state.client['AMD_HASH']
    print('Connection successfull with DB..')


@app.on_event("shutdown")
async def shutdown_event():
    app.state.client.close()


def get_app_information(app):
    package_name = app.get_package()
    app_name = app.get_app_name()
    version_name = app.get_androidversion_name()
    version_code = app.get_androidversion_code()
    print('got apk')
    info = {
        "Package Name:": package_name,
        "App Name:": app_name,
        "Version Name:": version_name,
        "Version Code:": version_code
    }
    return info


def get_app_features(app):
    global ds, ds_columns, single_name_columns
    dalvikVM = dvm.DalvikVMFormat(app.get_dex())
    apk_all_features = {}

    def get_permission(app):
        prm = set()
        permissions = app.get_permissions()
        for perm in permissions:
            p = perm.split('.')
            prm.add(p[2])
            apk_all_features[p[2]] = 1
            # print('Permissions :', p[2])
        print('permissions derived')
        return prm

    def get_intent(app):
        ints = set()
        manifest = app.get_android_manifest_xml()
        # # Get all the activities with their intent filters
        activities = manifest.findall(".//activity")

        # Iterate through activities to extract intent filters and actions

        for activity in activities:
            intent_filters = activity.findall(".//intent-filter")
            for intent_filter in intent_filters:
                actions = intent_filter.findall(".//action")
                for action in actions:
                    action_name = action.get(
                        "{http://schemas.android.com/apk/res/android}name")
                    # print("Action:", action_name)
                    ints.add(action_name)
                    apk_all_features[action_name] = 1
        print('Actions derived')
        return ints

    def get_app_test_dataframe():
        apk_test_set = {}
        for col in ds.columns:
            if col == 'class':
                continue
            if col not in apk_all_features:
                apk_test_set[col] = [0]
            else:
                apk_test_set[col] = [1]
        # print(apk_test_set)
        return pd.DataFrame(apk_test_set)

    perms = get_permission(app)
    ints = get_intent(app)
    res = {"Permissions": perms, "Actions": ints,
           "feature": get_app_test_dataframe()}
    return res


def load_model():
    with open('drebin_dt_model_random0.pkl', 'rb')as file:
        drebin_model = pickle.load(file)
    return drebin_model


def predict(dataframe) -> str:
    model = load_model()
    res = model.predict(dataframe)[0]
    if res == 1:
        return "File is Benign"
    else:
        return "File is Malicious"


def getVTResponse(vtanalysis_link):

    fileId = vtanalysis_link['data']['id']
    print(fileId)

    res = {}
    try:
        res = requests.get(
            vturl+'/analyses/'+fileId, headers=vtHeaders)

        res = json.loads(res.text)

    except Exception as e:
        print('vt analysis request failed!', e)
        return

    file_info = res['meta']['file_info']
    stats = res['data']['attributes']['stats']
    f_data = {
        "id": fileId,
        "links": res['data']['links'],
        "size": file_info['size'],
        "sha256": file_info['sha256'],
        "md5": file_info['md5'],
        "sha1": file_info['sha1'],
        "stats": stats,
        "attributes": res['data']['attributes']
    }
    try:
        app.state.db['HashDetail'].insert_one(f_data)
    except Exception as e:
        print('Error while saving data', e)
    return f_data


@app.get("/")
async def root():
    html_content = """
    <html>
    <head>
        <title>FastAPI H1 Example</title>
    </head>
    <body>
        <h1>Hello, FastAPI!</h1>
    </body>
    </html>
    """
    # return HTMLResponse(content=html_content)
    msg = "Hello world"
    # print(JSONResponse(msg))
    return JSONResponse(msg)


@app.post('/upload')
async def upload(file: UploadFile):
    starttime = time.time()
    contents = await file.read()
    info = {}
    try:
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(contents)
            temp_file_path = temp_file.name

            f = {"file": temp_file}

            vtres = requests.post(vturl+'/files', files=f, headers=vtHeaders)

            vtData = getVTResponse(json.loads(vtres.text))

            a = apk.APK(temp_file_path)
            info['App metadata'] = get_app_information(a)
            app_features = get_app_features(a)
            info["Permission"] = app_features['Permissions']
            info["Actions"] = app_features['Actions']
            info['Dynamic data'] = vtData
            info['Result'] = predict(app_features['feature'])

            temp_file.close()

            os.remove(temp_file_path)

    except Exception as e:
        print(e.__cause__)
        return HTMLResponse(content=f"An error occurred: {str(e)}")

    if not info:
        return "Error occured"
    endtime = time.time()
    timetook = endtime - starttime
    print(f'Time taken to upload - {timetook}')
    return info


@app.get('/hash/{hash}')
async def getHashDetail(hash: str):
    doc = list(app.state.db['HashDetail'].find({'sha256': hash}))
    if not len(doc):
        return "No such file"
    return doc[0]


@app.get('/file/{file}')
async def upload(file: str):
    print('request...')
    with open('testAPK/'+file, "rb") as file:
        file_contents = file.read()
    contents = file_contents
    info = {}
    try:

        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_file.write(contents)
            temp_file_path = temp_file.name
            a = apk.APK(temp_file_path)
            info["App metadata"] = get_app_information(a)
            app_features = get_app_features(a)
            info["Permission"] = app_features['Permissions']
            info["Actions"] = app_features['Actions']
            info["Result"] = predict(app_features['feature'])

            temp_file.close()
            os.remove(temp_file_path)

    except Exception as e:
        # print(e)
        return HTMLResponse(content=f"An error occurred: {str(e)}")

    if not info:
        return "Error occured"

    return info


@app.get('/dir/{dir}')
async def uploadDir(dir: str):
    dir_test_set = {}
    all_items = os.listdir(dir)
    # Filter out directories to get only files
    # files = [item for item in all_items if os.path.isfile(os.path.join(folder_path, item))]
    for item in all_items:
        with open('testAPK/'+item, "rb") as file:
            file_contents = file.read()
        contents = file_contents
        info = {}
        try:

            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                temp_file.write(contents)
                temp_file_path = temp_file.name
                a = apk.APK(temp_file_path)
                info["App metadata"] = get_app_information(a)
                app_features = get_app_features(a)
                info["Permission"] = app_features['Permissions']
                info["Actions"] = app_features['Actions']
                info["Result"] = predict(app_features['feature'])
                temp_file.close()
                os.remove(temp_file_path)

        except Exception as e:
            # print(e)
            return HTMLResponse(content=f"An error occurred: {str(e)}")

        if not info:
            return "Error occured"

        dir_test_set[item] = info
    return dir_test_set


@app.post('/db/findSHA256/{sha256}')
async def findSHA256(sha256: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"sha256_hash": sha256}))
    return len(doclist)


@app.post('/db/findSHA1/{sha1}')
async def findSHA1(sha1: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"sha1_hash": sha1}))
    return len(doclist)


@app.post('/db/findMD5/{md5}')
async def findMD5(md5: str) -> int:
    doclist = list(app.state.db['Hash532'].find({"md5_hash": md5}))
    return len(doclist)
